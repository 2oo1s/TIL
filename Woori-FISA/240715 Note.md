# 0715 TIL

## 더블 콜론 (::)

- Java 8에서 추가된 메소드 연산자

- (객체::메소드)

    - ex) (Customer::getId), (System.out::println)

```java
Customer c1 = new Customer("id1", 23, "newbie");
Customer c2 = new Customer("id2", 42, "gold");
Customer c3 = new Customer("id3", 56, "vip");

List<Customer> customers = Arrays.asList(c1, c2, c3);

System.out.println("====== 1. for문 ======");
for(Customer c : customers)
    System.out.println(c);

System.out.println("====== 2. 람다식 ======");   
customers.forEach(c -> System.out.println(c));

// 2. 람다식에서 한 변수 선언을 안해도 돼서 더 간결함
System.out.println("====== 3. 더블 콜론 ======");   
customers.forEach(System.out::println);

System.out.println("====== 3-1. 더블 콜론 ======");   
Arrays.asList(c1, c2, c3).forEach(c -> System.out.println(c));
```

## 람다식

- 메서드를 '하나의 식'으로 표현한 것

- `@FunctionalInterface` 

    - 인터페이스가 함수형 인터페이스임을 나타내기 위해 사용

    - <b>함수형 인터페이스란?</b> 정확히 하나의 추상 메서드를 가지는 인터페이스

```java
@FunctionalInterface
interface Calc {
	public int calc(int v1, int v2);
}

public class Solution {

	public static void main(String[] args) {

		Calc c1 = new Calc() {
			@Override
			public int calc(int v1, int v2) {
				return v1 + v2;
			}
		};

        // 람다식을 통해 메소드 재정의
		Calc cc1 = (v1, v2) -> v1 * v2;
		int v = cc1.calc(10, 20);
		System.out.println(v);  // 200

        /*
		 * (v1, v2) - 값을 받고자 하는 선언
		 * -> 받은 데이터를 오른쪽으로 넘기겠다는 선언
		 * v1 + v2 : 두 개의 변수가 보유한 데이터값을 더함 반환
		 * 더한 값이 cc1에 대입
		 */

		cc1 = (v1, v2) -> {
			return v1 / v2;
		};
		v = cc1.calc(10, 20);
		System.out.println(v);  // 0

		cc1 = (v1, v2) -> {
			System.out.println(v1 + v2);    // 120
			return v1 - v2;
		};

		v = cc1.calc(100, 20);
		System.out.println(v); // 80
	}
}
```
기능이 한 개일 때는 중괄호 안해도 되지만, 기능이 여러개 있을 때는 중괄호 하는 것이 필요함

## Stream API

- 컬렉션(List, Set 등)과 같은 데이터 소스를 처리하는 데 사용

- 가독성을 높이기 위해 설계 (간결한 코드 작성 가능)

```java
public class Solution {

	public static void main(String[] args) {
		List<String> datas = Arrays.asList("a", "b", "c", "d", "e");
		List<String> datas2 = Arrays.asList("a4", "b", "cat", "develop", "egg");

		// step01
		// double 연산자 + forEach() 활용해서 출력해보기
		System.out.println("============ Step 01 ============");

		datas.forEach(System.out::println);

		// step02 - b 문자열 제외하고 출력
		// 데이터 하나씩 뽑아서 출력
		System.out.println("\n============ Step 02 ============");

		datas.forEach(v -> {
			if (!v.equals("b")) // 객체들의 내용값 비교 메소드
				System.out.println(v);
		});

		// step03
		System.out.println("\n============ Step 03 ============");

		datas.stream().filter(v -> !v.equals("b")).forEach(System.out::println);

		// step04 - String data 문자열 길이가 1인 경우 제외하고, 문자열 길이 출력
		System.out.println("\n============ Step 04 ============");

		datas2.stream().filter(v -> v.length() != 1).forEach(v -> System.out.println(v.length()));

		// step05 - 사용자 정의 객체 타입(= 참조 타입, 클래스 타입) 활용
		System.out.println("\n============ Step 05 ============");

		ArrayList<Customer> list1 = new ArrayList<>();

		list1.add(new Customer("id1", "pw1"));
		list1.add(new Customer("id2", "pw2"));
		list1.add(new Customer("id3", "pw3"));

		// id2만 제외한 고객의 id 정보만 출력
		list1.stream().filter(v -> !v.getId().equals("id2")).forEach(v -> System.out.println(v.getId()));

		// step06 - 연산식
		System.out.println("\n============ Step 06 ============");
		List<String> datas3 = Arrays.asList("1", "2", "3", "4", "5");

		int result = datas3.stream().mapToInt(Integer::parseInt).sum();
		System.out.println(result);

		System.out.println(datas3.stream().mapToDouble(Double::parseDouble).sum()); // 15.0

		System.out.println(datas3.stream().mapToInt(Integer::parseInt).max()); // OptionalInt[5]

		System.out.println(datas3.stream().mapToInt(Integer::parseInt).count()); // 5

		System.out.println(datas3.stream().mapToInt(Integer::parseInt).min().getAsInt()); // OptionalInt[1]
	}
}
```

### 위 코드에서 사용된 주요 메소드 설명

`stream()` : 컬렉션(List, Set 등)에서 스트림을 생성

`filter()` : 조건에 따라 요소를 필터링 -> 조건을 만족하는 것들만 남겨 새로운 스트림 생성

`mapToDouble(), mapToInt()` : 각각 스트림의 요소를 변환하여 기본형(double, int, etc...) 스트림을 생성

`getAsInt()` : `OptionalInt`나 `IntStream` 같은 기본형 스트림에서 사용, 현재 스트림의 값을 int로 가져오는 메소드

## OPtional
```java
public class Solution {
	/*
	 * 프로그램 실행 중지를 방지하기 위한 처리 코드는 어떻게?
	 */
	
	@Test
	public void step081() {
		HashMap<String, Customer> map = new HashMap<>();
		
		map.put("id1", new Customer("id1", "pw1", 15, "Seoul", "newbie", "female"));
		map.put("id2", new Customer("id2", "pw2", 23, "Busan", "gold", "male"));
		map.put("id3", new Customer("id3", "pw3", 56, "Seoul", "vip", "female"));

		Optional<HashMap<String, Customer>> opt = Optional.ofNullable(map);

		System.out.println("============= 1 진입 =============");
		
		opt.ifPresent(m -> {
			System.out.println(m.values().stream().filter(c -> (c.getAge() < 20)).mapToInt(Customer::getAge).sum());
		});
		
		System.out.println("============= 2 진입 =============");
	}
	
	// @Test
	public void step08() {
		HashMap<String, Customer> map = null;

		Optional<HashMap<String, Customer>> opt = Optional.ofNullable(map);

		System.out.println("============= 1 진입 =============");
		
		opt.ifPresent(m -> {
			System.out.println(m.values().stream().filter(c -> (c.getAge() < 20)).mapToInt(Customer::getAge).sum());
		});
		
		System.out.println("============= 2 진입 =============");
	}

	// @Test
	public void step07() {
		// String v = null;
		String v = "fisa";

		Optional<String> opt = Optional.ofNullable(v);
		System.out.println(opt.isEmpty()); // true || false
		System.out.println(opt.isPresent()); // false || true
		System.out.println(opt.orElse("null인 경우 메세지 출력")); // null인 경우 메세지 출력 || fisa
		opt.ifPresent(v2 -> System.out.println(v2)); // 아예 무시 || fisa
	}

	/*
	 * of() : null은 불허
	 * 		ifPresent() 불필요
	 */

	// @Test
	public void step06() {
		String v = null;

		Optional<String> opt = Optional.of(v);
		opt.ifPresent(v2 -> System.out.println(v2));
	}

	/*
	 * ofNullable() : null 또는 실제 객체로 생성 
	 * 단, null 필터링은 ifPresent() 활용도 가능 
	 * ifPresent() : Optional 객체 내부에 null이면 skip
	 */
	// @Test
	public void step05() {
		String v = "fisa";

		Optional<String> opt = Optional.ofNullable(v);
		opt.ifPresent(v2 -> System.out.println(v2));
	}

	/*
	 * ofNullable() - null과 객체 다 수용
	 * get() - 실제 Optional 객체에 저장된 데이터 값 반환 메소드
	 * 		 - empty인 경우 실행 예외 발생
	 */
	// @Test
	public void step04() {
		String v = null;
		String v1 = "fisa";

		Optional<String> opt = Optional.ofNullable(v);
		Optional<String> opt1 = Optional.ofNullable(v1);

		System.out.println(opt); // Optional.empty -> 에러는 안 뜸
		System.out.println(opt.get()); // 예외 발생
		System.out.println(opt1); // Optional[fisa]
		System.out.println(opt1.get()); // fisa
	}

	// @Test
	public void step03() { // step02 실행 문제 해결, old한 처리 방식
		String v = null;
		if (v != null)
			System.out.println(v.length());
	}

	// @Test
	public void step02() {
		String v = null;
		System.out.println(v.length()); // 실행 시, NullPointer 발생
	}

	public void step01() {
		HashMap<String, Customer> map = new HashMap<>();

		map.put("id1", new Customer("id1", "pw1", 15, "Seoul", "newbie", "female"));
		map.put("id2", new Customer("id2", "pw2", 23, "Busan", "gold", "male"));
		map.put("id3", new Customer("id3", "pw3", 56, "Seoul", "vip", "female"));

		map.forEach((k, v) -> System.out.println(k + " " + v));

		// map에 저장되어 있는 모든 고객의 나이 합을 출력하세요
		map.values().stream().mapToInt(Customer::getAge).sum();

		// 나이가 20 미만인 고객의 나이 합을 출력하세요
		int res = map.values().stream()
                              .filter(c -> (c.getAge() < 20))
                              .mapToInt(Customer::getAge).sum();

		System.out.println(res);
	}
}
```